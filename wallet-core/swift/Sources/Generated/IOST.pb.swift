// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: IOST.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The enumeration defines the signature algorithm.
public enum TW_IOST_Proto_Algorithm: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// unknown
  case unknown // = 0

  /// secp256k1
  case secp256K1 // = 1

  /// ed25519
  case ed25519 // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .secp256K1
    case 2: self = .ed25519
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .secp256K1: return 1
    case .ed25519: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TW_IOST_Proto_Algorithm: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TW_IOST_Proto_Algorithm] = [
    .unknown,
    .secp256K1,
    .ed25519,
  ]
}

#endif  // swift(>=4.2)

/// The message defines transaction action struct.
public struct TW_IOST_Proto_Action {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// contract name
  public var contract: String = String()

  /// action name
  public var actionName: String = String()

  /// data
  public var data: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The message defines transaction amount limit struct.
public struct TW_IOST_Proto_AmountLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// token name
  public var token: String = String()

  /// limit value
  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The message defines signature struct.
public struct TW_IOST_Proto_Signature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// signature algorithm
  public var algorithm: TW_IOST_Proto_Algorithm = .unknown

  /// signature bytes
  public var signature: Data = SwiftProtobuf.Internal.emptyData

  /// public key
  public var publicKey: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The message defines the transaction request.
public struct TW_IOST_Proto_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// transaction timestamp
  public var time: Int64 = 0

  /// expiration timestamp
  public var expiration: Int64 = 0

  /// gas price
  public var gasRatio: Double = 0

  /// gas limit
  public var gasLimit: Double = 0

  /// delay nanoseconds
  public var delay: Int64 = 0

  /// chain id
  public var chainID: UInt32 = 0

  /// action list
  public var actions: [TW_IOST_Proto_Action] = []

  /// amount limit
  public var amountLimit: [TW_IOST_Proto_AmountLimit] = []

  /// signer list
  public var signers: [String] = []

  /// signatures of signers
  public var signatures: [TW_IOST_Proto_Signature] = []

  /// publisher
  public var publisher: String = String()

  /// signatures of publisher
  public var publisherSigs: [TW_IOST_Proto_Signature] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_IOST_Proto_AccountInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var activeKey: Data = SwiftProtobuf.Internal.emptyData

  public var ownerKey: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Input data necessary to create a signed transaction.
public struct TW_IOST_Proto_SigningInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: TW_IOST_Proto_AccountInfo {
    get {return _storage._account ?? TW_IOST_Proto_AccountInfo()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {_uniqueStorage()._account = nil}

  public var transactionTemplate: TW_IOST_Proto_Transaction {
    get {return _storage._transactionTemplate ?? TW_IOST_Proto_Transaction()}
    set {_uniqueStorage()._transactionTemplate = newValue}
  }
  /// Returns true if `transactionTemplate` has been explicitly set.
  public var hasTransactionTemplate: Bool {return _storage._transactionTemplate != nil}
  /// Clears the value of `transactionTemplate`. Subsequent reads from it will return its default value.
  public mutating func clearTransactionTemplate() {_uniqueStorage()._transactionTemplate = nil}

  public var transferDestination: String {
    get {return _storage._transferDestination}
    set {_uniqueStorage()._transferDestination = newValue}
  }

  public var transferAmount: String {
    get {return _storage._transferAmount}
    set {_uniqueStorage()._transferAmount = newValue}
  }

  public var transferMemo: String {
    get {return _storage._transferMemo}
    set {_uniqueStorage()._transferMemo = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Transaction signing output.
public struct TW_IOST_Proto_SigningOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Signed transaction
  public var transaction: TW_IOST_Proto_Transaction {
    get {return _storage._transaction ?? TW_IOST_Proto_Transaction()}
    set {_uniqueStorage()._transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  public var hasTransaction: Bool {return _storage._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  public mutating func clearTransaction() {_uniqueStorage()._transaction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TW.IOST.Proto"

extension TW_IOST_Proto_Algorithm: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SECP256K1"),
    2: .same(proto: "ED25519"),
  ]
}

extension TW_IOST_Proto_Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contract"),
    2: .standard(proto: "action_name"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.contract)
      case 2: try decoder.decodeSingularStringField(value: &self.actionName)
      case 3: try decoder.decodeSingularStringField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contract.isEmpty {
      try visitor.visitSingularStringField(value: self.contract, fieldNumber: 1)
    }
    if !self.actionName.isEmpty {
      try visitor.visitSingularStringField(value: self.actionName, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_IOST_Proto_Action, rhs: TW_IOST_Proto_Action) -> Bool {
    if lhs.contract != rhs.contract {return false}
    if lhs.actionName != rhs.actionName {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_IOST_Proto_AmountLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AmountLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      case 2: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_IOST_Proto_AmountLimit, rhs: TW_IOST_Proto_AmountLimit) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_IOST_Proto_Signature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Signature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "algorithm"),
    2: .same(proto: "signature"),
    3: .standard(proto: "public_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.algorithm)
      case 2: try decoder.decodeSingularBytesField(value: &self.signature)
      case 3: try decoder.decodeSingularBytesField(value: &self.publicKey)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.algorithm != .unknown {
      try visitor.visitSingularEnumField(value: self.algorithm, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 2)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_IOST_Proto_Signature, rhs: TW_IOST_Proto_Signature) -> Bool {
    if lhs.algorithm != rhs.algorithm {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_IOST_Proto_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Transaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "expiration"),
    3: .standard(proto: "gas_ratio"),
    4: .standard(proto: "gas_limit"),
    5: .same(proto: "delay"),
    6: .standard(proto: "chain_id"),
    7: .same(proto: "actions"),
    8: .standard(proto: "amount_limit"),
    9: .same(proto: "signers"),
    10: .same(proto: "signatures"),
    11: .same(proto: "publisher"),
    12: .standard(proto: "publisher_sigs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.time)
      case 2: try decoder.decodeSingularInt64Field(value: &self.expiration)
      case 3: try decoder.decodeSingularDoubleField(value: &self.gasRatio)
      case 4: try decoder.decodeSingularDoubleField(value: &self.gasLimit)
      case 5: try decoder.decodeSingularInt64Field(value: &self.delay)
      case 6: try decoder.decodeSingularUInt32Field(value: &self.chainID)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.actions)
      case 8: try decoder.decodeRepeatedMessageField(value: &self.amountLimit)
      case 9: try decoder.decodeRepeatedStringField(value: &self.signers)
      case 10: try decoder.decodeRepeatedMessageField(value: &self.signatures)
      case 11: try decoder.decodeSingularStringField(value: &self.publisher)
      case 12: try decoder.decodeRepeatedMessageField(value: &self.publisherSigs)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 1)
    }
    if self.expiration != 0 {
      try visitor.visitSingularInt64Field(value: self.expiration, fieldNumber: 2)
    }
    if self.gasRatio != 0 {
      try visitor.visitSingularDoubleField(value: self.gasRatio, fieldNumber: 3)
    }
    if self.gasLimit != 0 {
      try visitor.visitSingularDoubleField(value: self.gasLimit, fieldNumber: 4)
    }
    if self.delay != 0 {
      try visitor.visitSingularInt64Field(value: self.delay, fieldNumber: 5)
    }
    if self.chainID != 0 {
      try visitor.visitSingularUInt32Field(value: self.chainID, fieldNumber: 6)
    }
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 7)
    }
    if !self.amountLimit.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.amountLimit, fieldNumber: 8)
    }
    if !self.signers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.signers, fieldNumber: 9)
    }
    if !self.signatures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signatures, fieldNumber: 10)
    }
    if !self.publisher.isEmpty {
      try visitor.visitSingularStringField(value: self.publisher, fieldNumber: 11)
    }
    if !self.publisherSigs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publisherSigs, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_IOST_Proto_Transaction, rhs: TW_IOST_Proto_Transaction) -> Bool {
    if lhs.time != rhs.time {return false}
    if lhs.expiration != rhs.expiration {return false}
    if lhs.gasRatio != rhs.gasRatio {return false}
    if lhs.gasLimit != rhs.gasLimit {return false}
    if lhs.delay != rhs.delay {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.amountLimit != rhs.amountLimit {return false}
    if lhs.signers != rhs.signers {return false}
    if lhs.signatures != rhs.signatures {return false}
    if lhs.publisher != rhs.publisher {return false}
    if lhs.publisherSigs != rhs.publisherSigs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_IOST_Proto_AccountInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "active_key"),
    3: .standard(proto: "owner_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularBytesField(value: &self.activeKey)
      case 3: try decoder.decodeSingularBytesField(value: &self.ownerKey)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.activeKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.activeKey, fieldNumber: 2)
    }
    if !self.ownerKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_IOST_Proto_AccountInfo, rhs: TW_IOST_Proto_AccountInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.activeKey != rhs.activeKey {return false}
    if lhs.ownerKey != rhs.ownerKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_IOST_Proto_SigningInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigningInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .standard(proto: "transaction_template"),
    3: .standard(proto: "transfer_destination"),
    4: .standard(proto: "transfer_amount"),
    5: .standard(proto: "transfer_memo"),
  ]

  fileprivate class _StorageClass {
    var _account: TW_IOST_Proto_AccountInfo? = nil
    var _transactionTemplate: TW_IOST_Proto_Transaction? = nil
    var _transferDestination: String = String()
    var _transferAmount: String = String()
    var _transferMemo: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _transactionTemplate = source._transactionTemplate
      _transferDestination = source._transferDestination
      _transferAmount = source._transferAmount
      _transferMemo = source._transferMemo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._account)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._transactionTemplate)
        case 3: try decoder.decodeSingularStringField(value: &_storage._transferDestination)
        case 4: try decoder.decodeSingularStringField(value: &_storage._transferAmount)
        case 5: try decoder.decodeSingularStringField(value: &_storage._transferMemo)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._transactionTemplate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._transferDestination.isEmpty {
        try visitor.visitSingularStringField(value: _storage._transferDestination, fieldNumber: 3)
      }
      if !_storage._transferAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._transferAmount, fieldNumber: 4)
      }
      if !_storage._transferMemo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._transferMemo, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_IOST_Proto_SigningInput, rhs: TW_IOST_Proto_SigningInput) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._transactionTemplate != rhs_storage._transactionTemplate {return false}
        if _storage._transferDestination != rhs_storage._transferDestination {return false}
        if _storage._transferAmount != rhs_storage._transferAmount {return false}
        if _storage._transferMemo != rhs_storage._transferMemo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_IOST_Proto_SigningOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigningOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
  ]

  fileprivate class _StorageClass {
    var _transaction: TW_IOST_Proto_Transaction? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transaction = source._transaction
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._transaction)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._transaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_IOST_Proto_SigningOutput, rhs: TW_IOST_Proto_SigningOutput) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transaction != rhs_storage._transaction {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
